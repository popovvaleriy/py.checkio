def disconnected_users(net, users, source, crushes):  # net = [['A', 'B'],['B', 'C'],['C', 'D']]
    list_crushes = []
    list_source = [source]
    print(list_source)

    if source in crushes:
        return sum(users.values())
    counter = 0
    while counter <=len(net):
        for i,j in net:
            if i in list_source and j not in crushes:
                list_source.append(j)
            if j in list_source and i not in crushes:
                list_crushes.append(i)
        counter = counter +1

    print(set(list_source))  # {'C', 'D'} списки вышек где есть ретранслятор
    print(set(list_crushes))  # {'C', 'D'} списки вышек где есть вышедшая из строя вышка и вышка не подкл. к source
  
    print(sum(users.values()) - sum([users[i] for i in set(list_source)])) 
    return (sum(users.values()) - sum([users[i] for i in set(list_source)]))

if __name__ == '__main__':
    assert disconnected_users([['A', 'B'],['B', 'C'],['C', 'D']], {'A': 10,'B': 20,'C': 30,'D': 40},'A', ['C']) # == 70
    #assert disconnected_users([['A', 'B'],['B', 'D'],['A', 'C'],['C', 'D']], {'A': 10,'B': 0,'C': 0,'D': 40},'A', ['B']) #== 0
    assert disconnected_users([['A', 'B'],['A', 'C'],['A', 'D'],['A', 'E'],['A', 'F']], {'A': 10,'B': 10,'C': 10,'D': 10,'E': 10,'F': 10 },'C', ['A']) #== 50
    assert disconnected_users([['A', 'B'],['B', 'C'],['C', 'D'],['A', 'E'],['A', 'F']], {'A': 10,'B': 10,'C': 10,'D': 10,'E': 10,'F': 10 },'C', ['B']) #30
"""
Добро пожаловать в GridLand. Все граждане здесь подключены через глобальную внутреннюю сеть,
потому что основным способом общения является электронная почта. Строительство нового района
всегда начинается с возведения вышки - районного центра. Все жители подключены к этой вышке,
чтобы иметь возможность отправлять и получать электронные письма. Все вышки GridLand подключены,
поэтому одна вышка может отправлять электронные письма между связанными вышками.
Таким образом, независимо от того, насколько велик город, все пользователи могут отправлять сообщения друг другу до того момента,
пока все вышки подключены.

Мэр GridLand использует эту сеть, чтобы в случае необходимости быстро отправлять экстренные сообщения всем гражданам.
Но система не идеальна. В случае разрушения одной из вышек, все жители района, где она была возведена,
могут остаться отключенными от этих экстренных емейл сообщений.
Данное происшествие также может быть причиной повреждения связи в смежных районах,
если их вышки не имеют других способов подключения.
Чтобы разрешить данную проблему мэр использует почтовых голубей - старый метод отправки почты,
который был изобретен до глобальной внутренней сети. Граждане, которые все еще подключены к сети,
получают экстренные сообщения по электронной почте, но отключенные граждане получают их от этих голубей.

Ваша миссия - выяснить, сколько нужно голубей, если некоторые из вышек разрушены.

Входные данные: Четыре параметра: структура сети (в виде списка соединений между вышками),
пользователи на каждой вышке (в виде dict, где ключи - имя вышки, а значения - количество пользователей),
название вышки, отправляющей электронную почту, и список разрушенных вышек.
Выходные данные: Int. Количество пользователей, которые не получат экстренные сообщения.

Пример:

disconnected_users([
    ['A', 'B'],
    ['B', 'C'],
    ['C', 'D']
], {
    'A': 10,
    'B': 20,
    'C': 30,
    'D': 40
},
    'A', ['C']) == 70

disconnected_users([
    ['A', 'B'],
    ['B', 'D'],
    ['A', 'C'],
    ['C', 'D']
], {
    'A': 10,
    'B': 0,
    'C': 0,
    'D': 40
},
    'A', ['B']) == 0


disconnected_users([
    ['A', 'B'],
    ['A', 'C'],
    ['A', 'D'],
    ['A', 'E'],
    ['A', 'F']
], {
    'A': 10,
    'B': 10,
    'C': 10,
    'D': 10,
    'E': 10,
    'F': 10
},
    'C', ['A']) == 50

"""

